---
timezone: UTC+8
---

> 请在上边的 timezone 添加你的当地时区(UTC)，这会有助于你的打卡状态的自动化更新，如果没有添加，默认为北京时间 UTC+8 时区


# 你的名字

1. 自我介绍 大家好我是Andy
2. 你认为你会完成这次共学小组吗？会的
3. 你感兴趣的小组 DeFi
4. 你的微信号 15518659137
5. 质押的交易哈希 0xf615e28195f5f401eb6e12367c358aeabd346199d0cc51a0c3d00023fcbc0929

## Notes

<!-- Content_START -->

### 2025.12.1

 哈希
  对于hash函数 $H(x)$
	- sha: Secure Hash Algorithm
	- 有以下性质: 
		- collision resistance:
			- 对于该函数, 如果 x 不等于 y, 那么 H(x) 不等于 H(y)
			- sha256利用了上述原理, 如果传输时文件被修改了, 那么sha就变化了, 说明文件不安全
		- 注意应当保证输入空间是足够大的, 不然可以通过**暴力破解破解**出来!
		- hiding:
			- 根据H(x), 几乎不可能找到原来的x
		- digital equivalent of a sealed envlope (digital commitment):
			- 应用: 我对某事的预测是a, 想要在事情发生后才能公布给大家说, 我的预测是否正确, 但是我又不能让a影响到这件事情(比如我预测股票涨, 别人知道了, 判断偏移)
				- 我可以计算H(a)公布
				- 事件发生后公布a, 如果a和H(a)能够对得上, 那么就可以了
			- 注意: 假设对股票预测, 如果股票的数量比较少, 为了防止被穷举出来, 采用股票序号拼接一个随机数当做输入
				- 保证输入**空间大, 输入是随机的, 输出是均匀的, 不发生碰撞**
	- puzzle friendly:
		- 对于某种特殊输出, 比如 00000 + 5个k
			- 你没法知道哪个输入更有可能得到这个输出
		- 挖矿的目的, 就是找到某一个块头 , 使得:
			- H(block header) <= target
	- 有上述可知, 找到x很难, 但是验证H(x)很容易:
		- 故: difficult to solve but easy to verify
 签名:
- 椭圆曲线数字签名:
	- 私钥签名后, 只有公钥能验证签名的有效性
	- 私钥无法从公钥和签名中推出,所以比较安全
- 非对称RSA:
	- 内容用公钥加密, 发给主机, 主机用私钥解开
- 比特币的开户:
	- 创建公钥私钥对: public key, private key 非对称加密
	- 加密和解密用的是同一个人的公钥和私钥
		- 我要给你发信息: 用你的公钥加密, 发给你, 你用你的私钥解密
	- 公钥相当于银行账号, 私钥相当于自己的银行卡密码
	- 比特币转账: 
		- 我先用私钥, 对合约进行签名, 然后对方用我的公钥验证合约的正确性
			- 如何做到用另一个密钥来验证合约的正确呢?
- a good source of randomness:
	- 如果公私钥生成的随机性不好, 可以通过大量公私钥生成破解你的账号密码 就完了
	- 无论是数字签名的生成, 还是公私钥的生成, 都要有好的随机源 
		- 数字签名如果不能得到随机, 通过大量生成可以得到你的签名
		- 由加密的性质可知, 如果数字签名被破解, 那么你的私钥也就被破解了


### 2025.12.2

- 比特币是 transaction-based : 也就是说只记录交易记录, 不记录账户
	- 隐私性较好? 因为只要能说明你的转账的额度是从哪里来的就行
- 以太坊: account-based ledger: 记录账户, 另一种形式
- 比特币全节点要在内存中维护一个 UTXO 的数据结构
	- 以便快速检测出双花攻击
	- Unspent Transaction Output
		- UTXO会保存转入但没花的记录
			- 比如A给了C三个BTC, 会保存起来
			- 如果C又转给了D, 那么上面那一条记录就没了
- 两个激励机制:
	1. 出块奖励: 当前矿机的主要目的, 玩出一个快可能有一些比特币
	2. 交易小费, 挖出块的人有计量权, 可以写入交易, 帮别人写入交易会收小费
- 出块的难度为什么会调整, 为什么可以保证出块的难度在10min左右呢?
```cpp
class CBlockHeader
{
public:
	// header
	int32_t nVersion;// 固定, 不能改
	uint256 hashPrevBlock; // 前一个块的 hash 不能改
	uint256 hashMerkleRoot; // 可以改它!
	uint32_t nTime; // 时间可以在一定范围内进行调整
	uint32_t nBits; // 按照协议要求定期调整, 不能随便改
	uint32_t nNonce;
}
```
- 我们挖币的目的:
	- 有效条件是: `hash(block_header) < target`
	- target越小, 单次成功概率越低, 需要平均哈希次数多, 难度大
	- target是由nBits 按照某种数学公式得到的
- 比特币的全网理想挖币速度是: 每10分钟可以挖出一个区块
	- 由于全网算力不断增长, 如果想要维持10分钟一个区块的速度, 必须动态调整 nBits 使得计算更多的次数才能挖出区块
	- 由于每一个区块平均尝试次数一定, 你的算力越大, 你越有可能挖出这个区块, 得到这个比特币
- 只改`nNonce`显然搜索空间不够大, 还可以改`Header`中的别的内容
	-  比如 `hashMerkleRoot`
		- 由于挖出块中是有铸币交易的 由于 CoinBase 域可以随便改, 从而扩大了搜索空间
			- 改了 coinbase 交易后, 通过 merkle tree 的哈希值变化一直传播到最上面 使得 Merkle Root 发生了变化
- 故可以进行两重循环:
	1. 外层改 coinbase域中的 extra nonce: 64位空间可以修改
	2. 内层改 nonce : 32位的尝试空间
- 比特币交易验证, 通过脚本进行执行:
	- 此块的输入脚本和前面块的输出脚本拼到一起进行执行
	- 如果可以顺利执行, 那么成功了

### 2025.12.3
 Merkle tree
- 思路和binary tree 类似, 只是指针还是用了  hash pointer

- 一笔交易产生时, 各部分的作用:

| **角色/概念**           | **核心职责**                                                                                            |
| ------------------- | --------------------------------------------------------------------------------------------------- |
| **交易 (Tx)**         | 记录资产转移的具体指令。是区块链上数据流动的基础单元。                                                                         |
| **区块 (Block)**      | **永久记录**一组已确认、已验证的交易。是区块链的基本组成单位。                                                                   |
| **全节点 (Full Node)** | 1. **存储**完整的区块链数据（所有区块和所有交易）。2. **验证**所有交易和新区块的有效性。3. **提供**数据服务，如向轻节点提供 **Merkle Proof**。          |
| **矿工/验证者**          | 1. **竞争打包**新交易（从小明那里）。2. **计算 Merkle Root** 并构建新区块。3. **进行共识计算**（如 PoW 的 Nonce 寻找），将新区块添加到链上。       |
| **轻节点 (SPV)**       | 不存储完整区块链数据，仅下载**区块头**和**待验证交易**。依靠 **Merkle Tree** 和 **全节点** 提供的 **Merkle Proof** 来验证其特定交易是否被包含在链上。 |
| **Merkle Tree**     | **高效且安全地验证**数据完整性。将区块内的所有交易浓缩成一个单一的 **Merkle Root**，用于区块头和轻节点验证。                                    |


| **阶段**       | **核心行动**                                                                | **关键产物/结果**                            |
| ------------ | ----------------------------------------------------------------------- | -------------------------------------- |
| **1. 创建与广播** | 小明创建并用数字签名确认交易，通过网络将交易广播给全节点。                                           | 交易进入全节点的**内存池 (Mempool)**，等待被打包。       |
| **2. 区块打包**  | 矿工从内存池中选择交易，**计算 Merkle Root**，并将 Merkle Root 写入新的区块头。矿工从内存池选择一大堆内容进行交易 | 一个包含了交易、Merkle Root 和上一个区块哈希的**待定区块**。 |
| **3. 共识竞争**  | 矿工竞争计算，找到一个有效的 **区块哈希**（例如通过 Nonce）。                                    | 成功的矿工将新区块广播到全网。                        |
| **4. 验证与上链** | 全网其他全节点验证新区块的有效性（包括重新计算 Merkle Root）。一旦多数节点同意，新区块被添加到链尾。                | 小明的交易**被永久记录上链**。                      |
| **5. 交易验证**  | 小明（轻节点）向全节点请求 **Merkle Proof**，在本地验证交易是否上链。                             | **交易状态确认为“已完成”**。                      |
- **Merkle Proof**包含的内容:
	- 路径哈希值, 沿着 Merkle Tree从叶子结点到 Merkle Root 路径上 所有必须的兄弟哈希值
	- 方向指示, 应该和下一个哈希值如何拼接
- 轻节点(也就是你的移动设备)想要验证这笔交易:
	- 全节点发送手机路径: 收集从 H(tx) 到最顶端所有的兄弟哈希值, 发给手机, 这样手机通过进行两两哈希运算, 算出一个 Merkle Root , 和区块的 Merkle Root 进行对比, 即可证明这个东西确实包含在里面的
	- 可见是 logn 的
<!-- Content_END -->
